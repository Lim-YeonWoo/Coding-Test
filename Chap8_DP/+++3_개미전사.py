'''
p.220
[Chap8] DP
3_개미 전사

# 문제 설명 :
    배열에서 인접한 원소는 방문하지 못할때
    처음부터 끝까지 어떻게 방문해야
    방문한 원소의 합이 가장 크겠는가?

# 문제 풀이 :
    (첫시도 - 틀림)
    이미 방문한 칸은 생각하지 않고
    해당 위치에서 +2할지 +3할지만 따지면 된다.

    거꾸로 생각하면 해당 위치를 -2에서 올지 -3에서 올지이므로
    f(x) = max( f(x-2),
                f(x-3))
          + a[x] 가 된다.

    DP문제.
    bottom up 으로 구현해보자.

    (정답풀이)
    *** dp[i] 값에는 [i]까지 오는데에 최댓값을 저장하면 된다. i를 꼭 들릴 필요가 없다.
    예를 들어 dp[2] = dp[0] + dp[2]라고 해버리면 dp[]는 계속 증가하는 모습이어야하는데 그렇지 않다.

    *** 그러면 점화식도 틀린게 된다.
    위의 풀이는 dp[i]를 꼭 i를 들린다 생각 했기 때문

    *** x까지 오는데에 최댓값은 (이전칸 들리기) or (두번째 이전칸 들리고 현재칸 들리기)
    f(x) = max( f(x-1),
                f(x-2) + a[x] )


# 어려웠던 점 :
    dp[i]의 정의를 잘못 생각해서 꼬였다.
'''

n = int(input())
a = list(map(int, input().split()))

dp = [0] * n
dp[0] = a[0]
#dp[1] = a[1]
dp[1] = max(a[0], a[1]) #dp[1]값도 이렇게 생각해야한다.

for x in range(2, n):
    dp[x] = max(dp[x-1], dp[x-2] + a[x])

print(dp[n-1])
